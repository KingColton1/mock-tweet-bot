const { AttachmentBuilder } = require('discord.js');
const canvas = require('@napi-rs/canvas');
const { request } = require('undici');
const { channelID } = require('../libs/config.js');

async function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';

    for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && i > 0) {
            context.fillText(line, x, y);
            line = words[i] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    context.fillText(line, x, y);
}

async function createTweet(interaction, content) {
    const tweetChannel = interaction.guild.channels.cache.get(channelID);
    const canvasImg = canvas.createCanvas(1100, 750);
	const context = canvasImg.getContext('2d');

    const padding = 80;

    const background = await canvas.loadImage('./assets/background.png');
    context.drawImage(background, 0, 0, canvasImg.width, canvasImg.height);

    // Set avatar size and position
    const avatarSize = 120;
    const avatarX = 80;
    const avatarY = 80;

    // Draw the text on the canvas
    const textStartX = avatarX + avatarSize + 20;
    const textStartY = avatarY + 60;
    
    // Display Name
    context.font = 'bold 40px sans-serif';
    context.fillStyle = '#000';
    context.fillText(interaction.member.displayName, textStartX, textStartY);

    // Username
    context.font = '25px sans-serif';
    context.fillStyle = '#000';
    context.fillText(`@${interaction.user.username}`, textStartX, textStartY + 30);

    // Tweet content generated by user
    const contentStartX = padding;
    const contentStartY = avatarY + avatarSize + padding;
    const contentMaxWidth = canvasImg.width - 2 * padding;
    const lineHeight = 60;
    context.font = '50px sans-serif';
    context.fillStyle = '#000';
    wrapText(context, content, contentStartX, contentStartY, contentMaxWidth, lineHeight);

    // Make the avatar circular
    context.beginPath();
    context.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2, true);
    context.closePath();
    context.clip();


    // Using undici to make HTTP requests for better performance
	const { body } = await request(interaction.user.displayAvatarURL({ extension: 'jpg' }));
	const avatar = await canvas.loadImage(await body.arrayBuffer());
    context.drawImage(avatar, avatarX, avatarY, avatarSize, avatarSize);

    const attachment = new AttachmentBuilder(await canvasImg.encode('png'), { name: 'profile-image.png' });
    await tweetChannel.send({ files: [attachment] });
}

module.exports = {
    createTweet
}